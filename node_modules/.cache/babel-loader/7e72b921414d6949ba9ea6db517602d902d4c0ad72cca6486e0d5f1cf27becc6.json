{"ast":null,"code":"export class DiffEngine {\n  performComparison(originalText, changedText, settings) {\n    const {\n      diffMode,\n      ignoreCase,\n      ignoreWhitespace,\n      ignorePunctuation\n    } = settings;\n\n    // Preprocess texts based on ignore options\n    const processedOriginal = this.preprocessText(originalText, {\n      ignoreCase,\n      ignoreWhitespace,\n      ignorePunctuation\n    });\n    const processedChanged = this.preprocessText(changedText, {\n      ignoreCase,\n      ignoreWhitespace,\n      ignorePunctuation\n    });\n    switch (diffMode) {\n      case 'word':\n        return this.performWordComparison(processedOriginal, processedChanged);\n      case 'char':\n        return this.performCharComparison(processedOriginal, processedChanged);\n      default:\n        return this.performLineComparison(processedOriginal, processedChanged);\n    }\n  }\n  preprocessText(text, options) {\n    let processed = text;\n    if (options.ignoreCase) {\n      processed = processed.toLowerCase();\n    }\n    if (options.ignoreWhitespace) {\n      processed = processed.replace(/\\s+/g, ' ').trim();\n    }\n    if (options.ignorePunctuation) {\n      processed = processed.replace(/[^\\w\\s]/g, '');\n    }\n    return processed;\n  }\n  performLineComparison(originalText, changedText) {\n    const originalLines = originalText.split(/\\r?\\n/);\n    const changedLines = changedText.split(/\\r?\\n/);\n    const diff = this.computeLineDiff(originalLines, changedLines);\n    const stats = {\n      linesAdded: 0,\n      linesRemoved: 0,\n      linesModified: 0\n    };\n    const originalResult = [];\n    const changedResult = [];\n\n    // Process original lines\n    diff.original.forEach((lineInfo, index) => {\n      const lineObj = {\n        content: this.escapeHtml(lineInfo.content),\n        type: lineInfo.type,\n        lineNumber: index + 1\n      };\n      if (lineInfo.type === 'removed') stats.linesRemoved++;\n      if (lineInfo.type === 'modified') stats.linesModified++;\n      originalResult.push(lineObj);\n    });\n\n    // Process changed lines\n    diff.changed.forEach((lineInfo, index) => {\n      const lineObj = {\n        content: this.escapeHtml(lineInfo.content),\n        type: lineInfo.type,\n        lineNumber: index + 1\n      };\n      if (lineInfo.type === 'added') stats.linesAdded++;\n      changedResult.push(lineObj);\n    });\n    return {\n      originalLines: originalResult,\n      changedLines: changedResult,\n      stats\n    };\n  }\n  performWordComparison(originalText, changedText) {\n    const originalWords = this.splitIntoWords(originalText);\n    const changedWords = this.splitIntoWords(changedText);\n    const wordDiff = this.computeImprovedWordDiff(originalWords, changedWords);\n    const stats = {\n      wordsAdded: 0,\n      wordsRemoved: 0,\n      wordsModified: 0,\n      totalChanges: 0\n    };\n    let originalHtml = '';\n    let changedHtml = '';\n\n    // Process original words with better counting\n    wordDiff.original.forEach(item => {\n      if (item.type === 'removed') {\n        // Only count actual words, not whitespace\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          stats.wordsRemoved++;\n        }\n        originalHtml += `<span class=\"word-removed\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          stats.wordsModified++;\n        }\n        originalHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        originalHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Process changed words with better counting\n    wordDiff.changed.forEach(item => {\n      if (item.type === 'added') {\n        // Only count actual words, not whitespace\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          stats.wordsAdded++;\n        }\n        changedHtml += `<span class=\"word-added\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          // Don't double count modified words\n        }\n        changedHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        changedHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Calculate total changes more accurately\n    stats.totalChanges = stats.wordsAdded + stats.wordsRemoved + stats.wordsModified;\n    return {\n      originalLines: [{\n        content: originalHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      changedLines: [{\n        content: changedHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      stats\n    };\n  }\n  performCharComparison(originalText, changedText) {\n    const charDiff = this.computeImprovedCharDiff(originalText, changedText);\n    const stats = {\n      charactersAdded: 0,\n      charactersRemoved: 0,\n      charactersModified: 0,\n      totalChanges: 0\n    };\n    let originalHtml = '';\n    let changedHtml = '';\n\n    // Process original characters with grouping for better visualization\n    charDiff.original.forEach(item => {\n      if (item.type === 'removed') {\n        stats.charactersRemoved++;\n        originalHtml += `<span class=\"char-removed\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        stats.charactersModified++;\n        originalHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        originalHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Process changed characters with grouping\n    charDiff.changed.forEach(item => {\n      if (item.type === 'added') {\n        stats.charactersAdded++;\n        changedHtml += `<span class=\"char-added\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        // Don't double count modified characters\n        changedHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        changedHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Calculate total changes\n    stats.totalChanges = stats.charactersAdded + stats.charactersRemoved + stats.charactersModified;\n    return {\n      originalLines: [{\n        content: originalHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      changedLines: [{\n        content: changedHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      stats\n    };\n  }\n  computeLineDiff(originalLines, changedLines) {\n    const m = originalLines.length;\n    const n = changedLines.length;\n\n    // Create DP table for LCS\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    // Fill the DP table\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (originalLines[i - 1] === changedLines[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n\n    // Backtrack to build the diff\n    const result = {\n      original: [],\n      changed: []\n    };\n    let i = m,\n      j = n;\n    while (i > 0 || j > 0) {\n      if (i > 0 && j > 0 && originalLines[i - 1] === changedLines[j - 1]) {\n        result.original.unshift({\n          content: originalLines[i - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedLines[j - 1],\n          type: 'unchanged'\n        });\n        i--;\n        j--;\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\n        result.original.unshift({\n          content: originalLines[i - 1],\n          type: 'removed'\n        });\n        i--;\n      } else {\n        result.changed.unshift({\n          content: changedLines[j - 1],\n          type: 'added'\n        });\n        j--;\n      }\n    }\n\n    // Post-process to detect modified lines (similar lines that changed)\n    return this.detectLineModifications(result);\n  }\n  detectLineModifications(diffResult) {\n    const original = [...diffResult.original];\n    const changed = [...diffResult.changed];\n\n    // Look for patterns where a line was removed and another similar line was added\n    for (let i = 0; i < original.length; i++) {\n      if (original[i].type === 'removed') {\n        const removedLine = original[i].content.trim();\n\n        // Look for similar added lines within a reasonable range\n        for (let j = Math.max(0, i - 3); j < Math.min(changed.length, i + 4); j++) {\n          if (changed[j] && changed[j].type === 'added') {\n            const addedLine = changed[j].content.trim();\n            if (removedLine && addedLine && this.areLinesSimilar(removedLine, addedLine)) {\n              original[i].type = 'modified';\n              changed[j].type = 'modified';\n              break;\n            }\n          }\n        }\n      }\n    }\n    return {\n      original,\n      changed\n    };\n  }\n  areLinesSimilar(line1, line2) {\n    // Don't consider empty lines as similar\n    if (!line1.trim() || !line2.trim()) return false;\n\n    // If lines are identical, they should be unchanged (shouldn't reach here)\n    if (line1 === line2) return false;\n\n    // More lenient length check - allow up to 80% difference for small changes\n    const maxLength = Math.max(line1.length, line2.length);\n    const minLength = Math.min(line1.length, line2.length);\n    if (minLength / maxLength < 0.2) {\n      return false;\n    }\n\n    // Calculate similarity using multiple approaches\n    const words1 = line1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);\n    const words2 = line2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);\n    if (words1.length === 0 || words2.length === 0) return false;\n\n    // Approach 1: Count exact word matches\n    const commonWords = words1.filter(word => words2.includes(word)).length;\n    const totalUniqueWords = new Set([...words1, ...words2]).size;\n    const wordSimilarity = commonWords / totalUniqueWords;\n\n    // Approach 2: Check if most words are the same (for minor word substitutions)\n    const maxWords = Math.max(words1.length, words2.length);\n    const minWords = Math.min(words1.length, words2.length);\n    const wordCountSimilarity = minWords / maxWords;\n\n    // Approach 3: Character-level similarity for very similar lines\n    const charSimilarity = this.calculateCharacterSimilarity(line1, line2);\n\n    // Consider lines similar if they meet any of these criteria:\n    // 1. High word similarity (30% or more common words)\n    // 2. Very similar word count (90%+) with decent word overlap (25%+)\n    // 3. High character similarity (85%+) for minor changes\n    return wordSimilarity >= 0.3 || wordCountSimilarity >= 0.9 && commonWords / maxWords >= 0.25 || charSimilarity >= 0.85;\n  }\n  calculateCharacterSimilarity(str1, str2) {\n    // Simple character-based similarity using longest common subsequence\n    const m = str1.length;\n    const n = str2.length;\n    if (m === 0 || n === 0) return 0;\n\n    // Use a simplified approach for performance\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (str1[i - 1].toLowerCase() === str2[j - 1].toLowerCase()) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n    const lcsLength = dp[m][n];\n    const maxLength = Math.max(m, n);\n    return lcsLength / maxLength;\n  }\n  splitIntoWords(text) {\n    const regex = /(\\S+|\\s+)/g;\n    return text.match(regex) || [];\n  }\n  computeImprovedWordDiff(originalWords, changedWords) {\n    // Use Myers' algorithm for better diff performance\n    const result = this.myersWordDiff(originalWords, changedWords);\n\n    // Post-process to detect word modifications (similar words that changed)\n    return this.detectWordModifications(result);\n  }\n  myersWordDiff(originalWords, changedWords) {\n    const m = originalWords.length;\n    const n = changedWords.length;\n    const max = m + n;\n    const v = Array(2 * max + 1).fill(0);\n    const trace = [];\n    for (let d = 0; d <= max; d++) {\n      trace.push([...v]);\n      for (let k = -d; k <= d; k += 2) {\n        let x;\n        if (k === -d || k !== d && v[k - 1 + max] < v[k + 1 + max]) {\n          x = v[k + 1 + max];\n        } else {\n          x = v[k - 1 + max] + 1;\n        }\n        let y = x - k;\n        while (x < m && y < n && originalWords[x] === changedWords[y]) {\n          x++;\n          y++;\n        }\n        v[k + max] = x;\n        if (x >= m && y >= n) {\n          return this.buildWordPath(originalWords, changedWords, trace, d);\n        }\n      }\n    }\n\n    // Fallback to simple LCS if Myers fails\n    return this.computeWordDiff(originalWords, changedWords);\n  }\n  buildWordPath(originalWords, changedWords, trace, d) {\n    const result = {\n      original: [],\n      changed: []\n    };\n    let x = originalWords.length;\n    let y = changedWords.length;\n    for (let depth = d; depth > 0; depth--) {\n      const v = trace[depth];\n      const k = x - y;\n      const max = originalWords.length + changedWords.length;\n      let prevK;\n      if (k === -depth || k !== depth && v[k - 1 + max] < v[k + 1 + max]) {\n        prevK = k + 1;\n      } else {\n        prevK = k - 1;\n      }\n      const prevX = v[prevK + max];\n      const prevY = prevX - prevK;\n      while (x > prevX && y > prevY) {\n        result.original.unshift({\n          content: originalWords[x - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedWords[y - 1],\n          type: 'unchanged'\n        });\n        x--;\n        y--;\n      }\n      if (depth > 0) {\n        if (x > prevX) {\n          result.original.unshift({\n            content: originalWords[x - 1],\n            type: 'removed'\n          });\n          x--;\n        } else {\n          result.changed.unshift({\n            content: changedWords[y - 1],\n            type: 'added'\n          });\n          y--;\n        }\n      }\n    }\n    return result;\n  }\n  detectWordModifications(diffResult) {\n    // Look for patterns where a word was removed and another added nearby\n    const original = [...diffResult.original];\n    const changed = [...diffResult.changed];\n\n    // Simple heuristic: if words are similar (edit distance < 3), mark as modified\n    for (let i = 0; i < original.length; i++) {\n      if (original[i].type === 'removed') {\n        const removedWord = original[i].content.trim();\n\n        // Look for similar added words\n        for (let j = 0; j < changed.length; j++) {\n          if (changed[j].type === 'added') {\n            const addedWord = changed[j].content.trim();\n            if (removedWord && addedWord && this.areWordsSimilar(removedWord, addedWord)) {\n              original[i].type = 'modified';\n              changed[j].type = 'modified';\n              break;\n            }\n          }\n        }\n      }\n    }\n    return {\n      original,\n      changed\n    };\n  }\n  areWordsSimilar(word1, word2) {\n    // Clean the words (remove punctuation for comparison)\n    const clean1 = word1.replace(/[^\\w]/g, '').toLowerCase();\n    const clean2 = word2.replace(/[^\\w]/g, '').toLowerCase();\n    if (clean1.length === 0 || clean2.length === 0) return false;\n    if (clean1 === clean2) return false; // Identical words should be unchanged\n\n    // More lenient length check for word substitutions\n    const maxLen = Math.max(clean1.length, clean2.length);\n    const minLen = Math.min(clean1.length, clean2.length);\n\n    // Allow more length variation for word substitutions\n    if (minLen / maxLen < 0.3) return false;\n\n    // Calculate character-level similarity using LCS\n    const similarity = this.calculateWordSimilarity(clean1, clean2);\n\n    // Lower threshold for word similarity to catch more substitutions\n    return similarity >= 0.4; // 40% character similarity\n  }\n  calculateWordSimilarity(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    if (m === 0 || n === 0) return 0;\n\n    // Use dynamic programming to find longest common subsequence\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (word1[i - 1] === word2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n    const lcsLength = dp[m][n];\n    const maxLength = Math.max(m, n);\n    return lcsLength / maxLength;\n  }\n  computeWordDiff(originalWords, changedWords) {\n    const m = originalWords.length;\n    const n = changedWords.length;\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (originalWords[i - 1] === changedWords[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n    const result = {\n      original: [],\n      changed: []\n    };\n    let i = m,\n      j = n;\n    while (i > 0 || j > 0) {\n      if (i > 0 && j > 0 && originalWords[i - 1] === changedWords[j - 1]) {\n        result.original.unshift({\n          content: originalWords[i - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedWords[j - 1],\n          type: 'unchanged'\n        });\n        i--;\n        j--;\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\n        result.original.unshift({\n          content: originalWords[i - 1],\n          type: 'removed'\n        });\n        i--;\n      } else {\n        result.changed.unshift({\n          content: changedWords[j - 1],\n          type: 'added'\n        });\n        j--;\n      }\n    }\n    return result;\n  }\n  computeImprovedCharDiff(originalText, changedText) {\n    // Use character-level Myers algorithm with grouping for better visualization\n    const result = this.myersCharDiff(originalText, changedText);\n\n    // Group consecutive changes for better readability\n    return this.groupCharacterChanges(result);\n  }\n  myersCharDiff(originalText, changedText) {\n    const originalChars = Array.from(originalText);\n    const changedChars = Array.from(changedText);\n    const m = originalChars.length;\n    const n = changedChars.length;\n    const max = m + n;\n    if (max === 0) {\n      return {\n        original: [],\n        changed: []\n      };\n    }\n    const v = Array(2 * max + 1).fill(0);\n    const trace = [];\n    for (let d = 0; d <= max; d++) {\n      trace.push([...v]);\n      for (let k = -d; k <= d; k += 2) {\n        let x;\n        if (k === -d || k !== d && v[k - 1 + max] < v[k + 1 + max]) {\n          x = v[k + 1 + max];\n        } else {\n          x = v[k - 1 + max] + 1;\n        }\n        let y = x - k;\n        while (x < m && y < n && originalChars[x] === changedChars[y]) {\n          x++;\n          y++;\n        }\n        v[k + max] = x;\n        if (x >= m && y >= n) {\n          return this.buildCharPath(originalChars, changedChars, trace, d);\n        }\n      }\n    }\n\n    // Fallback to simple character diff\n    return this.computeCharDiff(originalText, changedText);\n  }\n  buildCharPath(originalChars, changedChars, trace, d) {\n    const result = {\n      original: [],\n      changed: []\n    };\n    let x = originalChars.length;\n    let y = changedChars.length;\n    for (let depth = d; depth > 0; depth--) {\n      const v = trace[depth];\n      const k = x - y;\n      const max = originalChars.length + changedChars.length;\n      let prevK;\n      if (k === -depth || k !== depth && v[k - 1 + max] < v[k + 1 + max]) {\n        prevK = k + 1;\n      } else {\n        prevK = k - 1;\n      }\n      const prevX = v[prevK + max];\n      const prevY = prevX - prevK;\n      while (x > prevX && y > prevY) {\n        result.original.unshift({\n          content: originalChars[x - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedChars[y - 1],\n          type: 'unchanged'\n        });\n        x--;\n        y--;\n      }\n      if (depth > 0) {\n        if (x > prevX) {\n          result.original.unshift({\n            content: originalChars[x - 1],\n            type: 'removed'\n          });\n          x--;\n        } else {\n          result.changed.unshift({\n            content: changedChars[y - 1],\n            type: 'added'\n          });\n          y--;\n        }\n      }\n    }\n    return result;\n  }\n  groupCharacterChanges(diffResult) {\n    // Group consecutive character changes for better visualization\n    const groupedOriginal = this.groupConsecutiveChanges(diffResult.original);\n    const groupedChanged = this.groupConsecutiveChanges(diffResult.changed);\n    return {\n      original: groupedOriginal,\n      changed: groupedChanged\n    };\n  }\n  groupConsecutiveChanges(items) {\n    if (!items || items.length === 0) return [];\n    const grouped = [];\n    let currentGroup = null;\n    for (const item of items) {\n      if (currentGroup && currentGroup.type === item.type && item.type !== 'unchanged') {\n        // Continue the current group\n        currentGroup.content += item.content;\n      } else {\n        // Start a new group\n        if (currentGroup) {\n          grouped.push(currentGroup);\n        }\n        currentGroup = {\n          ...item\n        };\n      }\n    }\n    if (currentGroup) {\n      grouped.push(currentGroup);\n    }\n    return grouped;\n  }\n  computeCharDiff(originalText, changedText) {\n    const originalChars = Array.from(originalText);\n    const changedChars = Array.from(changedText);\n    const m = originalChars.length;\n    const n = changedChars.length;\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (originalChars[i - 1] === changedChars[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n    const result = {\n      original: [],\n      changed: []\n    };\n    let i = m,\n      j = n;\n    while (i > 0 || j > 0) {\n      if (i > 0 && j > 0 && originalChars[i - 1] === changedChars[j - 1]) {\n        result.original.unshift({\n          content: originalChars[i - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedChars[j - 1],\n          type: 'unchanged'\n        });\n        i--;\n        j--;\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\n        result.original.unshift({\n          content: originalChars[i - 1],\n          type: 'removed'\n        });\n        i--;\n      } else {\n        result.changed.unshift({\n          content: changedChars[j - 1],\n          type: 'added'\n        });\n        j--;\n      }\n    }\n    return result;\n  }\n  escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n}","map":{"version":3,"names":["DiffEngine","performComparison","originalText","changedText","settings","diffMode","ignoreCase","ignoreWhitespace","ignorePunctuation","processedOriginal","preprocessText","processedChanged","performWordComparison","performCharComparison","performLineComparison","text","options","processed","toLowerCase","replace","trim","originalLines","split","changedLines","diff","computeLineDiff","stats","linesAdded","linesRemoved","linesModified","originalResult","changedResult","original","forEach","lineInfo","index","lineObj","content","escapeHtml","type","lineNumber","push","changed","originalWords","splitIntoWords","changedWords","wordDiff","computeImprovedWordDiff","wordsAdded","wordsRemoved","wordsModified","totalChanges","originalHtml","changedHtml","item","test","charDiff","computeImprovedCharDiff","charactersAdded","charactersRemoved","charactersModified","m","length","n","dp","Array","fill","map","i","j","Math","max","result","unshift","detectLineModifications","diffResult","removedLine","min","addedLine","areLinesSimilar","line1","line2","maxLength","minLength","words1","filter","w","words2","commonWords","word","includes","totalUniqueWords","Set","size","wordSimilarity","maxWords","minWords","wordCountSimilarity","charSimilarity","calculateCharacterSimilarity","str1","str2","lcsLength","regex","match","myersWordDiff","detectWordModifications","v","trace","d","k","x","y","buildWordPath","computeWordDiff","depth","prevK","prevX","prevY","removedWord","addedWord","areWordsSimilar","word1","word2","clean1","clean2","maxLen","minLen","similarity","calculateWordSimilarity","myersCharDiff","groupCharacterChanges","originalChars","from","changedChars","buildCharPath","computeCharDiff","groupedOriginal","groupConsecutiveChanges","groupedChanged","items","grouped","currentGroup","div","document","createElement","textContent","innerHTML"],"sources":["C:/Users/Joem/quickdiff-react/src/utils/DiffEngine.js"],"sourcesContent":["export class DiffEngine {\r\n  performComparison(originalText, changedText, settings) {\r\n    const { diffMode, ignoreCase, ignoreWhitespace, ignorePunctuation } = settings;\r\n    \r\n    // Preprocess texts based on ignore options\r\n    const processedOriginal = this.preprocessText(originalText, { ignoreCase, ignoreWhitespace, ignorePunctuation });\r\n    const processedChanged = this.preprocessText(changedText, { ignoreCase, ignoreWhitespace, ignorePunctuation });\r\n    \r\n    switch (diffMode) {\r\n      case 'word':\r\n        return this.performWordComparison(processedOriginal, processedChanged);\r\n      case 'char':\r\n        return this.performCharComparison(processedOriginal, processedChanged);\r\n      default:\r\n        return this.performLineComparison(processedOriginal, processedChanged);\r\n    }\r\n  }\r\n\r\n  preprocessText(text, options) {\r\n    let processed = text;\r\n    \r\n    if (options.ignoreCase) {\r\n      processed = processed.toLowerCase();\r\n    }\r\n    \r\n    if (options.ignoreWhitespace) {\r\n      processed = processed.replace(/\\s+/g, ' ').trim();\r\n    }\r\n    \r\n    if (options.ignorePunctuation) {\r\n      processed = processed.replace(/[^\\w\\s]/g, '');\r\n    }\r\n    \r\n    return processed;\r\n  }\r\n\r\n  performLineComparison(originalText, changedText) {\r\n    const originalLines = originalText.split(/\\r?\\n/);\r\n    const changedLines = changedText.split(/\\r?\\n/);\r\n    \r\n    const diff = this.computeLineDiff(originalLines, changedLines);\r\n    \r\n    const stats = {\r\n      linesAdded: 0,\r\n      linesRemoved: 0,\r\n      linesModified: 0\r\n    };\r\n    \r\n    const originalResult = [];\r\n    const changedResult = [];\r\n    \r\n    // Process original lines\r\n    diff.original.forEach((lineInfo, index) => {\r\n      const lineObj = {\r\n        content: this.escapeHtml(lineInfo.content),\r\n        type: lineInfo.type,\r\n        lineNumber: index + 1\r\n      };\r\n      \r\n      if (lineInfo.type === 'removed') stats.linesRemoved++;\r\n      if (lineInfo.type === 'modified') stats.linesModified++;\r\n      \r\n      originalResult.push(lineObj);\r\n    });\r\n    \r\n    // Process changed lines\r\n    diff.changed.forEach((lineInfo, index) => {\r\n      const lineObj = {\r\n        content: this.escapeHtml(lineInfo.content),\r\n        type: lineInfo.type,\r\n        lineNumber: index + 1\r\n      };\r\n      \r\n      if (lineInfo.type === 'added') stats.linesAdded++;\r\n      \r\n      changedResult.push(lineObj);\r\n    });\r\n    \r\n    return {\r\n      originalLines: originalResult,\r\n      changedLines: changedResult,\r\n      stats\r\n    };\r\n  }\r\n\r\n  performWordComparison(originalText, changedText) {\r\n    const originalWords = this.splitIntoWords(originalText);\r\n    const changedWords = this.splitIntoWords(changedText);\r\n    \r\n    const wordDiff = this.computeImprovedWordDiff(originalWords, changedWords);\r\n    \r\n    const stats = {\r\n      wordsAdded: 0,\r\n      wordsRemoved: 0,\r\n      wordsModified: 0,\r\n      totalChanges: 0\r\n    };\r\n    \r\n    let originalHtml = '';\r\n    let changedHtml = '';\r\n    \r\n    // Process original words with better counting\r\n    wordDiff.original.forEach(item => {\r\n      if (item.type === 'removed') {\r\n        // Only count actual words, not whitespace\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          stats.wordsRemoved++;\r\n        }\r\n        originalHtml += `<span class=\"word-removed\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          stats.wordsModified++;\r\n        }\r\n        originalHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        originalHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Process changed words with better counting\r\n    wordDiff.changed.forEach(item => {\r\n      if (item.type === 'added') {\r\n        // Only count actual words, not whitespace\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          stats.wordsAdded++;\r\n        }\r\n        changedHtml += `<span class=\"word-added\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          // Don't double count modified words\r\n        }\r\n        changedHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        changedHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Calculate total changes more accurately\r\n    stats.totalChanges = stats.wordsAdded + stats.wordsRemoved + stats.wordsModified;\r\n    \r\n    return {\r\n      originalLines: [{ content: originalHtml, type: '', lineNumber: 1 }],\r\n      changedLines: [{ content: changedHtml, type: '', lineNumber: 1 }],\r\n      stats\r\n    };\r\n  }\r\n\r\n  performCharComparison(originalText, changedText) {\r\n    const charDiff = this.computeImprovedCharDiff(originalText, changedText);\r\n    \r\n    const stats = {\r\n      charactersAdded: 0,\r\n      charactersRemoved: 0,\r\n      charactersModified: 0,\r\n      totalChanges: 0\r\n    };\r\n    \r\n    let originalHtml = '';\r\n    let changedHtml = '';\r\n    \r\n    // Process original characters with grouping for better visualization\r\n    charDiff.original.forEach(item => {\r\n      if (item.type === 'removed') {\r\n        stats.charactersRemoved++;\r\n        originalHtml += `<span class=\"char-removed\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        stats.charactersModified++;\r\n        originalHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        originalHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Process changed characters with grouping\r\n    charDiff.changed.forEach(item => {\r\n      if (item.type === 'added') {\r\n        stats.charactersAdded++;\r\n        changedHtml += `<span class=\"char-added\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        // Don't double count modified characters\r\n        changedHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        changedHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Calculate total changes\r\n    stats.totalChanges = stats.charactersAdded + stats.charactersRemoved + stats.charactersModified;\r\n    \r\n    return {\r\n      originalLines: [{ content: originalHtml, type: '', lineNumber: 1 }],\r\n      changedLines: [{ content: changedHtml, type: '', lineNumber: 1 }],\r\n      stats\r\n    };\r\n  }\r\n\r\n  computeLineDiff(originalLines, changedLines) {\r\n    const m = originalLines.length;\r\n    const n = changedLines.length;\r\n    \r\n    // Create DP table for LCS\r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    // Fill the DP table\r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (originalLines[i - 1] === changedLines[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Backtrack to build the diff\r\n    const result = { original: [], changed: [] };\r\n    let i = m, j = n;\r\n    \r\n    while (i > 0 || j > 0) {\r\n      if (i > 0 && j > 0 && originalLines[i - 1] === changedLines[j - 1]) {\r\n        result.original.unshift({\r\n          content: originalLines[i - 1],\r\n          type: 'unchanged'\r\n        });\r\n        result.changed.unshift({\r\n          content: changedLines[j - 1],\r\n          type: 'unchanged'\r\n        });\r\n        i--; j--;\r\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\r\n        result.original.unshift({\r\n          content: originalLines[i - 1],\r\n          type: 'removed'\r\n        });\r\n        i--;\r\n      } else {\r\n        result.changed.unshift({\r\n          content: changedLines[j - 1],\r\n          type: 'added'\r\n        });\r\n        j--;\r\n      }\r\n    }\r\n    \r\n    // Post-process to detect modified lines (similar lines that changed)\r\n    return this.detectLineModifications(result);\r\n  }\r\n\r\n  detectLineModifications(diffResult) {\r\n    const original = [...diffResult.original];\r\n    const changed = [...diffResult.changed];\r\n    \r\n    // Look for patterns where a line was removed and another similar line was added\r\n    for (let i = 0; i < original.length; i++) {\r\n      if (original[i].type === 'removed') {\r\n        const removedLine = original[i].content.trim();\r\n        \r\n        // Look for similar added lines within a reasonable range\r\n        for (let j = Math.max(0, i - 3); j < Math.min(changed.length, i + 4); j++) {\r\n          if (changed[j] && changed[j].type === 'added') {\r\n            const addedLine = changed[j].content.trim();\r\n            \r\n            if (removedLine && addedLine && this.areLinesSimilar(removedLine, addedLine)) {\r\n              original[i].type = 'modified';\r\n              changed[j].type = 'modified';\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return { original, changed };\r\n  }\r\n\r\n  areLinesSimilar(line1, line2) {\r\n    // Don't consider empty lines as similar\r\n    if (!line1.trim() || !line2.trim()) return false;\r\n    \r\n    // If lines are identical, they should be unchanged (shouldn't reach here)\r\n    if (line1 === line2) return false;\r\n    \r\n    // More lenient length check - allow up to 80% difference for small changes\r\n    const maxLength = Math.max(line1.length, line2.length);\r\n    const minLength = Math.min(line1.length, line2.length);\r\n    if (minLength / maxLength < 0.2) {\r\n      return false;\r\n    }\r\n    \r\n    // Calculate similarity using multiple approaches\r\n    const words1 = line1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);\r\n    const words2 = line2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);\r\n    \r\n    if (words1.length === 0 || words2.length === 0) return false;\r\n    \r\n    // Approach 1: Count exact word matches\r\n    const commonWords = words1.filter(word => words2.includes(word)).length;\r\n    const totalUniqueWords = new Set([...words1, ...words2]).size;\r\n    const wordSimilarity = commonWords / totalUniqueWords;\r\n    \r\n    // Approach 2: Check if most words are the same (for minor word substitutions)\r\n    const maxWords = Math.max(words1.length, words2.length);\r\n    const minWords = Math.min(words1.length, words2.length);\r\n    const wordCountSimilarity = minWords / maxWords;\r\n    \r\n    // Approach 3: Character-level similarity for very similar lines\r\n    const charSimilarity = this.calculateCharacterSimilarity(line1, line2);\r\n    \r\n    // Consider lines similar if they meet any of these criteria:\r\n    // 1. High word similarity (30% or more common words)\r\n    // 2. Very similar word count (90%+) with decent word overlap (25%+)\r\n    // 3. High character similarity (85%+) for minor changes\r\n    return (\r\n      wordSimilarity >= 0.3 ||\r\n      (wordCountSimilarity >= 0.9 && commonWords / maxWords >= 0.25) ||\r\n      charSimilarity >= 0.85\r\n    );\r\n  }\r\n\r\n  calculateCharacterSimilarity(str1, str2) {\r\n    // Simple character-based similarity using longest common subsequence\r\n    const m = str1.length;\r\n    const n = str2.length;\r\n    \r\n    if (m === 0 || n === 0) return 0;\r\n    \r\n    // Use a simplified approach for performance\r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (str1[i - 1].toLowerCase() === str2[j - 1].toLowerCase()) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const lcsLength = dp[m][n];\r\n    const maxLength = Math.max(m, n);\r\n    \r\n    return lcsLength / maxLength;\r\n  }\r\n\r\n  splitIntoWords(text) {\r\n    const regex = /(\\S+|\\s+)/g;\r\n    return text.match(regex) || [];\r\n  }\r\n\r\n  computeImprovedWordDiff(originalWords, changedWords) {\r\n    // Use Myers' algorithm for better diff performance\r\n    const result = this.myersWordDiff(originalWords, changedWords);\r\n    \r\n    // Post-process to detect word modifications (similar words that changed)\r\n    return this.detectWordModifications(result);\r\n  }\r\n\r\n  myersWordDiff(originalWords, changedWords) {\r\n    const m = originalWords.length;\r\n    const n = changedWords.length;\r\n    const max = m + n;\r\n    \r\n    const v = Array(2 * max + 1).fill(0);\r\n    const trace = [];\r\n    \r\n    for (let d = 0; d <= max; d++) {\r\n      trace.push([...v]);\r\n      \r\n      for (let k = -d; k <= d; k += 2) {\r\n        let x;\r\n        if (k === -d || (k !== d && v[k - 1 + max] < v[k + 1 + max])) {\r\n          x = v[k + 1 + max];\r\n        } else {\r\n          x = v[k - 1 + max] + 1;\r\n        }\r\n        \r\n        let y = x - k;\r\n        \r\n        while (x < m && y < n && originalWords[x] === changedWords[y]) {\r\n          x++;\r\n          y++;\r\n        }\r\n        \r\n        v[k + max] = x;\r\n        \r\n        if (x >= m && y >= n) {\r\n          return this.buildWordPath(originalWords, changedWords, trace, d);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Fallback to simple LCS if Myers fails\r\n    return this.computeWordDiff(originalWords, changedWords);\r\n  }\r\n\r\n  buildWordPath(originalWords, changedWords, trace, d) {\r\n    const result = { original: [], changed: [] };\r\n    let x = originalWords.length;\r\n    let y = changedWords.length;\r\n    \r\n    for (let depth = d; depth > 0; depth--) {\r\n      const v = trace[depth];\r\n      const k = x - y;\r\n      const max = originalWords.length + changedWords.length;\r\n      \r\n      let prevK;\r\n      if (k === -depth || (k !== depth && v[k - 1 + max] < v[k + 1 + max])) {\r\n        prevK = k + 1;\r\n      } else {\r\n        prevK = k - 1;\r\n      }\r\n      \r\n      const prevX = v[prevK + max];\r\n      const prevY = prevX - prevK;\r\n      \r\n      while (x > prevX && y > prevY) {\r\n        result.original.unshift({ content: originalWords[x - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedWords[y - 1], type: 'unchanged' });\r\n        x--;\r\n        y--;\r\n      }\r\n      \r\n      if (depth > 0) {\r\n        if (x > prevX) {\r\n          result.original.unshift({ content: originalWords[x - 1], type: 'removed' });\r\n          x--;\r\n        } else {\r\n          result.changed.unshift({ content: changedWords[y - 1], type: 'added' });\r\n          y--;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  detectWordModifications(diffResult) {\r\n    // Look for patterns where a word was removed and another added nearby\r\n    const original = [...diffResult.original];\r\n    const changed = [...diffResult.changed];\r\n    \r\n    // Simple heuristic: if words are similar (edit distance < 3), mark as modified\r\n    for (let i = 0; i < original.length; i++) {\r\n      if (original[i].type === 'removed') {\r\n        const removedWord = original[i].content.trim();\r\n        \r\n        // Look for similar added words\r\n        for (let j = 0; j < changed.length; j++) {\r\n          if (changed[j].type === 'added') {\r\n            const addedWord = changed[j].content.trim();\r\n            \r\n            if (removedWord && addedWord && this.areWordsSimilar(removedWord, addedWord)) {\r\n              original[i].type = 'modified';\r\n              changed[j].type = 'modified';\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return { original, changed };\r\n  }\r\n\r\n  areWordsSimilar(word1, word2) {\r\n    // Clean the words (remove punctuation for comparison)\r\n    const clean1 = word1.replace(/[^\\w]/g, '').toLowerCase();\r\n    const clean2 = word2.replace(/[^\\w]/g, '').toLowerCase();\r\n    \r\n    if (clean1.length === 0 || clean2.length === 0) return false;\r\n    if (clean1 === clean2) return false; // Identical words should be unchanged\r\n    \r\n    // More lenient length check for word substitutions\r\n    const maxLen = Math.max(clean1.length, clean2.length);\r\n    const minLen = Math.min(clean1.length, clean2.length);\r\n    \r\n    // Allow more length variation for word substitutions\r\n    if (minLen / maxLen < 0.3) return false;\r\n    \r\n    // Calculate character-level similarity using LCS\r\n    const similarity = this.calculateWordSimilarity(clean1, clean2);\r\n    \r\n    // Lower threshold for word similarity to catch more substitutions\r\n    return similarity >= 0.4; // 40% character similarity\r\n  }\r\n\r\n  calculateWordSimilarity(word1, word2) {\r\n    const m = word1.length;\r\n    const n = word2.length;\r\n    \r\n    if (m === 0 || n === 0) return 0;\r\n    \r\n    // Use dynamic programming to find longest common subsequence\r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (word1[i - 1] === word2[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const lcsLength = dp[m][n];\r\n    const maxLength = Math.max(m, n);\r\n    \r\n    return lcsLength / maxLength;\r\n  }\r\n\r\n  computeWordDiff(originalWords, changedWords) {\r\n    const m = originalWords.length;\r\n    const n = changedWords.length;\r\n    \r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (originalWords[i - 1] === changedWords[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const result = { original: [], changed: [] };\r\n    let i = m, j = n;\r\n    \r\n    while (i > 0 || j > 0) {\r\n      if (i > 0 && j > 0 && originalWords[i - 1] === changedWords[j - 1]) {\r\n        result.original.unshift({ content: originalWords[i - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedWords[j - 1], type: 'unchanged' });\r\n        i--; j--;\r\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\r\n        result.original.unshift({ content: originalWords[i - 1], type: 'removed' });\r\n        i--;\r\n      } else {\r\n        result.changed.unshift({ content: changedWords[j - 1], type: 'added' });\r\n        j--;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  computeImprovedCharDiff(originalText, changedText) {\r\n    // Use character-level Myers algorithm with grouping for better visualization\r\n    const result = this.myersCharDiff(originalText, changedText);\r\n    \r\n    // Group consecutive changes for better readability\r\n    return this.groupCharacterChanges(result);\r\n  }\r\n\r\n  myersCharDiff(originalText, changedText) {\r\n    const originalChars = Array.from(originalText);\r\n    const changedChars = Array.from(changedText);\r\n    \r\n    const m = originalChars.length;\r\n    const n = changedChars.length;\r\n    const max = m + n;\r\n    \r\n    if (max === 0) {\r\n      return { original: [], changed: [] };\r\n    }\r\n    \r\n    const v = Array(2 * max + 1).fill(0);\r\n    const trace = [];\r\n    \r\n    for (let d = 0; d <= max; d++) {\r\n      trace.push([...v]);\r\n      \r\n      for (let k = -d; k <= d; k += 2) {\r\n        let x;\r\n        if (k === -d || (k !== d && v[k - 1 + max] < v[k + 1 + max])) {\r\n          x = v[k + 1 + max];\r\n        } else {\r\n          x = v[k - 1 + max] + 1;\r\n        }\r\n        \r\n        let y = x - k;\r\n        \r\n        while (x < m && y < n && originalChars[x] === changedChars[y]) {\r\n          x++;\r\n          y++;\r\n        }\r\n        \r\n        v[k + max] = x;\r\n        \r\n        if (x >= m && y >= n) {\r\n          return this.buildCharPath(originalChars, changedChars, trace, d);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Fallback to simple character diff\r\n    return this.computeCharDiff(originalText, changedText);\r\n  }\r\n\r\n  buildCharPath(originalChars, changedChars, trace, d) {\r\n    const result = { original: [], changed: [] };\r\n    let x = originalChars.length;\r\n    let y = changedChars.length;\r\n    \r\n    for (let depth = d; depth > 0; depth--) {\r\n      const v = trace[depth];\r\n      const k = x - y;\r\n      const max = originalChars.length + changedChars.length;\r\n      \r\n      let prevK;\r\n      if (k === -depth || (k !== depth && v[k - 1 + max] < v[k + 1 + max])) {\r\n        prevK = k + 1;\r\n      } else {\r\n        prevK = k - 1;\r\n      }\r\n      \r\n      const prevX = v[prevK + max];\r\n      const prevY = prevX - prevK;\r\n      \r\n      while (x > prevX && y > prevY) {\r\n        result.original.unshift({ content: originalChars[x - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedChars[y - 1], type: 'unchanged' });\r\n        x--;\r\n        y--;\r\n      }\r\n      \r\n      if (depth > 0) {\r\n        if (x > prevX) {\r\n          result.original.unshift({ content: originalChars[x - 1], type: 'removed' });\r\n          x--;\r\n        } else {\r\n          result.changed.unshift({ content: changedChars[y - 1], type: 'added' });\r\n          y--;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  groupCharacterChanges(diffResult) {\r\n    // Group consecutive character changes for better visualization\r\n    const groupedOriginal = this.groupConsecutiveChanges(diffResult.original);\r\n    const groupedChanged = this.groupConsecutiveChanges(diffResult.changed);\r\n    \r\n    return { original: groupedOriginal, changed: groupedChanged };\r\n  }\r\n\r\n  groupConsecutiveChanges(items) {\r\n    if (!items || items.length === 0) return [];\r\n    \r\n    const grouped = [];\r\n    let currentGroup = null;\r\n    \r\n    for (const item of items) {\r\n      if (currentGroup && currentGroup.type === item.type && item.type !== 'unchanged') {\r\n        // Continue the current group\r\n        currentGroup.content += item.content;\r\n      } else {\r\n        // Start a new group\r\n        if (currentGroup) {\r\n          grouped.push(currentGroup);\r\n        }\r\n        currentGroup = { ...item };\r\n      }\r\n    }\r\n    \r\n    if (currentGroup) {\r\n      grouped.push(currentGroup);\r\n    }\r\n    \r\n    return grouped;\r\n  }\r\n\r\n  computeCharDiff(originalText, changedText) {\r\n    const originalChars = Array.from(originalText);\r\n    const changedChars = Array.from(changedText);\r\n    \r\n    const m = originalChars.length;\r\n    const n = changedChars.length;\r\n    \r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (originalChars[i - 1] === changedChars[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const result = { original: [], changed: [] };\r\n    let i = m, j = n;\r\n    \r\n    while (i > 0 || j > 0) {\r\n      if (i > 0 && j > 0 && originalChars[i - 1] === changedChars[j - 1]) {\r\n        result.original.unshift({ content: originalChars[i - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedChars[j - 1], type: 'unchanged' });\r\n        i--; j--;\r\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\r\n        result.original.unshift({ content: originalChars[i - 1], type: 'removed' });\r\n        i--;\r\n      } else {\r\n        result.changed.unshift({ content: changedChars[j - 1], type: 'added' });\r\n        j--;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  escapeHtml(text) {\r\n    const div = document.createElement('div');\r\n    div.textContent = text;\r\n    return div.innerHTML;\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}