{"ast":null,"code":"export class DiffEngine {\n  performComparison(originalText, changedText, settings) {\n    const {\n      diffMode,\n      ignoreCase,\n      ignoreWhitespace,\n      ignorePunctuation\n    } = settings;\n\n    // Preprocess texts based on ignore options\n    const processedOriginal = this.preprocessText(originalText, {\n      ignoreCase,\n      ignoreWhitespace,\n      ignorePunctuation\n    });\n    const processedChanged = this.preprocessText(changedText, {\n      ignoreCase,\n      ignoreWhitespace,\n      ignorePunctuation\n    });\n    switch (diffMode) {\n      case 'word':\n        return this.performWordComparison(processedOriginal, processedChanged);\n      case 'char':\n        return this.performCharComparison(processedOriginal, processedChanged);\n      default:\n        return this.performLineComparison(processedOriginal, processedChanged);\n    }\n  }\n  preprocessText(text, options) {\n    let processed = text;\n    if (options.ignoreCase) {\n      processed = processed.toLowerCase();\n    }\n    if (options.ignoreWhitespace) {\n      processed = processed.replace(/\\s+/g, ' ').trim();\n    }\n    if (options.ignorePunctuation) {\n      processed = processed.replace(/[^\\w\\s]/g, '');\n    }\n    return processed;\n  }\n  performLineComparison(originalText, changedText) {\n    const originalLines = originalText.split(/\\r?\\n/);\n    const changedLines = changedText.split(/\\r?\\n/);\n    const diff = this.computeLineDiff(originalLines, changedLines);\n    const stats = {\n      linesAdded: 0,\n      linesRemoved: 0,\n      linesModified: 0\n    };\n    const originalResult = [];\n    const changedResult = [];\n\n    // Process original lines\n    diff.original.forEach((lineInfo, index) => {\n      const lineObj = {\n        content: this.escapeHtml(lineInfo.content),\n        type: lineInfo.type,\n        lineNumber: index + 1\n      };\n      if (lineInfo.type === 'removed') stats.linesRemoved++;\n      if (lineInfo.type === 'modified') stats.linesModified++;\n      originalResult.push(lineObj);\n    });\n\n    // Process changed lines\n    diff.changed.forEach((lineInfo, index) => {\n      const lineObj = {\n        content: this.escapeHtml(lineInfo.content),\n        type: lineInfo.type,\n        lineNumber: index + 1\n      };\n      if (lineInfo.type === 'added') stats.linesAdded++;\n      changedResult.push(lineObj);\n    });\n    return {\n      originalLines: originalResult,\n      changedLines: changedResult,\n      stats\n    };\n  }\n  performWordComparison(originalText, changedText) {\n    const originalWords = this.splitIntoWords(originalText);\n    const changedWords = this.splitIntoWords(changedText);\n    const wordDiff = this.computeImprovedWordDiff(originalWords, changedWords);\n    const stats = {\n      wordsAdded: 0,\n      wordsRemoved: 0,\n      wordsModified: 0,\n      totalChanges: 0\n    };\n    let originalHtml = '';\n    let changedHtml = '';\n\n    // Process original words with better counting\n    wordDiff.original.forEach(item => {\n      if (item.type === 'removed') {\n        // Only count actual words, not whitespace\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          stats.wordsRemoved++;\n        }\n        originalHtml += `<span class=\"word-removed\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          stats.wordsModified++;\n        }\n        originalHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        originalHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Process changed words with better counting\n    wordDiff.changed.forEach(item => {\n      if (item.type === 'added') {\n        // Only count actual words, not whitespace\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          stats.wordsAdded++;\n        }\n        changedHtml += `<span class=\"word-added\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        if (item.content.trim() && /\\S/.test(item.content)) {\n          // Don't double count modified words\n        }\n        changedHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        changedHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Calculate total changes more accurately\n    stats.totalChanges = stats.wordsAdded + stats.wordsRemoved + stats.wordsModified;\n    return {\n      originalLines: [{\n        content: originalHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      changedLines: [{\n        content: changedHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      stats\n    };\n  }\n  performCharComparison(originalText, changedText) {\n    const charDiff = this.computeImprovedCharDiff(originalText, changedText);\n    const stats = {\n      charactersAdded: 0,\n      charactersRemoved: 0,\n      charactersModified: 0,\n      totalChanges: 0\n    };\n    let originalHtml = '';\n    let changedHtml = '';\n\n    // Process original characters with grouping for better visualization\n    charDiff.original.forEach(item => {\n      if (item.type === 'removed') {\n        stats.charactersRemoved++;\n        originalHtml += `<span class=\"char-removed\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        stats.charactersModified++;\n        originalHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        originalHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Process changed characters with grouping\n    charDiff.changed.forEach(item => {\n      if (item.type === 'added') {\n        stats.charactersAdded++;\n        changedHtml += `<span class=\"char-added\">${this.escapeHtml(item.content)}</span>`;\n      } else if (item.type === 'modified') {\n        // Don't double count modified characters\n        changedHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\n      } else {\n        changedHtml += this.escapeHtml(item.content);\n      }\n    });\n\n    // Calculate total changes\n    stats.totalChanges = stats.charactersAdded + stats.charactersRemoved + stats.charactersModified;\n    return {\n      originalLines: [{\n        content: originalHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      changedLines: [{\n        content: changedHtml,\n        type: '',\n        lineNumber: 1\n      }],\n      stats\n    };\n  }\n  computeLineDiff(originalLines, changedLines) {\n    const m = originalLines.length;\n    const n = changedLines.length;\n\n    // Create DP table for LCS\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    // Fill the DP table\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (originalLines[i - 1] === changedLines[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n\n    // Backtrack to build the diff\n    const result = {\n      original: [],\n      changed: []\n    };\n    let i = m,\n      j = n;\n    while (i > 0 || j > 0) {\n      if (i > 0 && j > 0 && originalLines[i - 1] === changedLines[j - 1]) {\n        result.original.unshift({\n          content: originalLines[i - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedLines[j - 1],\n          type: 'unchanged'\n        });\n        i--;\n        j--;\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\n        result.original.unshift({\n          content: originalLines[i - 1],\n          type: 'removed'\n        });\n        i--;\n      } else {\n        result.changed.unshift({\n          content: changedLines[j - 1],\n          type: 'added'\n        });\n        j--;\n      }\n    }\n    return result;\n  }\n  splitIntoWords(text) {\n    const regex = /(\\S+|\\s+)/g;\n    return text.match(regex) || [];\n  }\n  computeImprovedWordDiff(originalWords, changedWords) {\n    // Use Myers' algorithm for better diff performance\n    const result = this.myersWordDiff(originalWords, changedWords);\n\n    // Post-process to detect word modifications (similar words that changed)\n    return this.detectWordModifications(result);\n  }\n  myersWordDiff(originalWords, changedWords) {\n    const m = originalWords.length;\n    const n = changedWords.length;\n    const max = m + n;\n    const v = Array(2 * max + 1).fill(0);\n    const trace = [];\n    for (let d = 0; d <= max; d++) {\n      trace.push([...v]);\n      for (let k = -d; k <= d; k += 2) {\n        let x;\n        if (k === -d || k !== d && v[k - 1 + max] < v[k + 1 + max]) {\n          x = v[k + 1 + max];\n        } else {\n          x = v[k - 1 + max] + 1;\n        }\n        let y = x - k;\n        while (x < m && y < n && originalWords[x] === changedWords[y]) {\n          x++;\n          y++;\n        }\n        v[k + max] = x;\n        if (x >= m && y >= n) {\n          return this.buildWordPath(originalWords, changedWords, trace, d);\n        }\n      }\n    }\n\n    // Fallback to simple LCS if Myers fails\n    return this.computeWordDiff(originalWords, changedWords);\n  }\n  buildWordPath(originalWords, changedWords, trace, d) {\n    const result = {\n      original: [],\n      changed: []\n    };\n    let x = originalWords.length;\n    let y = changedWords.length;\n    for (let depth = d; depth > 0; depth--) {\n      const v = trace[depth];\n      const k = x - y;\n      const max = originalWords.length + changedWords.length;\n      let prevK;\n      if (k === -depth || k !== depth && v[k - 1 + max] < v[k + 1 + max]) {\n        prevK = k + 1;\n      } else {\n        prevK = k - 1;\n      }\n      const prevX = v[prevK + max];\n      const prevY = prevX - prevK;\n      while (x > prevX && y > prevY) {\n        result.original.unshift({\n          content: originalWords[x - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedWords[y - 1],\n          type: 'unchanged'\n        });\n        x--;\n        y--;\n      }\n      if (depth > 0) {\n        if (x > prevX) {\n          result.original.unshift({\n            content: originalWords[x - 1],\n            type: 'removed'\n          });\n          x--;\n        } else {\n          result.changed.unshift({\n            content: changedWords[y - 1],\n            type: 'added'\n          });\n          y--;\n        }\n      }\n    }\n    return result;\n  }\n  detectWordModifications(diffResult) {\n    // Look for patterns where a word was removed and another added nearby\n    const original = [...diffResult.original];\n    const changed = [...diffResult.changed];\n\n    // Simple heuristic: if words are similar (edit distance < 3), mark as modified\n    for (let i = 0; i < original.length; i++) {\n      if (original[i].type === 'removed') {\n        const removedWord = original[i].content.trim();\n\n        // Look for similar added words\n        for (let j = 0; j < changed.length; j++) {\n          if (changed[j].type === 'added') {\n            const addedWord = changed[j].content.trim();\n            if (removedWord && addedWord && this.areWordsSimilar(removedWord, addedWord)) {\n              original[i].type = 'modified';\n              changed[j].type = 'modified';\n              break;\n            }\n          }\n        }\n      }\n    }\n    return {\n      original,\n      changed\n    };\n  }\n  areWordsSimilar(word1, word2) {\n    // Simple similarity check - could be enhanced with Levenshtein distance\n    if (word1.length === 0 || word2.length === 0) return false;\n    if (Math.abs(word1.length - word2.length) > 3) return false;\n\n    // Check if they share common prefix/suffix\n    const minLen = Math.min(word1.length, word2.length);\n    let commonChars = 0;\n    for (let i = 0; i < minLen; i++) {\n      if (word1[i].toLowerCase() === word2[i].toLowerCase()) {\n        commonChars++;\n      }\n    }\n    return commonChars / minLen > 0.6; // 60% similarity threshold\n  }\n  computeWordDiff(originalWords, changedWords) {\n    const m = originalWords.length;\n    const n = changedWords.length;\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (originalWords[i - 1] === changedWords[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n    const result = {\n      original: [],\n      changed: []\n    };\n    let i = m,\n      j = n;\n    while (i > 0 || j > 0) {\n      if (i > 0 && j > 0 && originalWords[i - 1] === changedWords[j - 1]) {\n        result.original.unshift({\n          content: originalWords[i - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedWords[j - 1],\n          type: 'unchanged'\n        });\n        i--;\n        j--;\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\n        result.original.unshift({\n          content: originalWords[i - 1],\n          type: 'removed'\n        });\n        i--;\n      } else {\n        result.changed.unshift({\n          content: changedWords[j - 1],\n          type: 'added'\n        });\n        j--;\n      }\n    }\n    return result;\n  }\n  computeImprovedCharDiff(originalText, changedText) {\n    // Use character-level Myers algorithm with grouping for better visualization\n    const result = this.myersCharDiff(originalText, changedText);\n\n    // Group consecutive changes for better readability\n    return this.groupCharacterChanges(result);\n  }\n  myersCharDiff(originalText, changedText) {\n    const originalChars = Array.from(originalText);\n    const changedChars = Array.from(changedText);\n    const m = originalChars.length;\n    const n = changedChars.length;\n    const max = m + n;\n    if (max === 0) {\n      return {\n        original: [],\n        changed: []\n      };\n    }\n    const v = Array(2 * max + 1).fill(0);\n    const trace = [];\n    for (let d = 0; d <= max; d++) {\n      trace.push([...v]);\n      for (let k = -d; k <= d; k += 2) {\n        let x;\n        if (k === -d || k !== d && v[k - 1 + max] < v[k + 1 + max]) {\n          x = v[k + 1 + max];\n        } else {\n          x = v[k - 1 + max] + 1;\n        }\n        let y = x - k;\n        while (x < m && y < n && originalChars[x] === changedChars[y]) {\n          x++;\n          y++;\n        }\n        v[k + max] = x;\n        if (x >= m && y >= n) {\n          return this.buildCharPath(originalChars, changedChars, trace, d);\n        }\n      }\n    }\n\n    // Fallback to simple character diff\n    return this.computeCharDiff(originalText, changedText);\n  }\n  buildCharPath(originalChars, changedChars, trace, d) {\n    const result = {\n      original: [],\n      changed: []\n    };\n    let x = originalChars.length;\n    let y = changedChars.length;\n    for (let depth = d; depth > 0; depth--) {\n      const v = trace[depth];\n      const k = x - y;\n      const max = originalChars.length + changedChars.length;\n      let prevK;\n      if (k === -depth || k !== depth && v[k - 1 + max] < v[k + 1 + max]) {\n        prevK = k + 1;\n      } else {\n        prevK = k - 1;\n      }\n      const prevX = v[prevK + max];\n      const prevY = prevX - prevK;\n      while (x > prevX && y > prevY) {\n        result.original.unshift({\n          content: originalChars[x - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedChars[y - 1],\n          type: 'unchanged'\n        });\n        x--;\n        y--;\n      }\n      if (depth > 0) {\n        if (x > prevX) {\n          result.original.unshift({\n            content: originalChars[x - 1],\n            type: 'removed'\n          });\n          x--;\n        } else {\n          result.changed.unshift({\n            content: changedChars[y - 1],\n            type: 'added'\n          });\n          y--;\n        }\n      }\n    }\n    return result;\n  }\n  groupCharacterChanges(diffResult) {\n    // Group consecutive character changes for better visualization\n    const groupedOriginal = this.groupConsecutiveChanges(diffResult.original);\n    const groupedChanged = this.groupConsecutiveChanges(diffResult.changed);\n    return {\n      original: groupedOriginal,\n      changed: groupedChanged\n    };\n  }\n  groupConsecutiveChanges(items) {\n    if (!items || items.length === 0) return [];\n    const grouped = [];\n    let currentGroup = null;\n    for (const item of items) {\n      if (currentGroup && currentGroup.type === item.type && item.type !== 'unchanged') {\n        // Continue the current group\n        currentGroup.content += item.content;\n      } else {\n        // Start a new group\n        if (currentGroup) {\n          grouped.push(currentGroup);\n        }\n        currentGroup = {\n          ...item\n        };\n      }\n    }\n    if (currentGroup) {\n      grouped.push(currentGroup);\n    }\n    return grouped;\n  }\n  computeCharDiff(originalText, changedText) {\n    const originalChars = Array.from(originalText);\n    const changedChars = Array.from(changedText);\n    const m = originalChars.length;\n    const n = changedChars.length;\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (originalChars[i - 1] === changedChars[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n    const result = {\n      original: [],\n      changed: []\n    };\n    let i = m,\n      j = n;\n    while (i > 0 || j > 0) {\n      if (i > 0 && j > 0 && originalChars[i - 1] === changedChars[j - 1]) {\n        result.original.unshift({\n          content: originalChars[i - 1],\n          type: 'unchanged'\n        });\n        result.changed.unshift({\n          content: changedChars[j - 1],\n          type: 'unchanged'\n        });\n        i--;\n        j--;\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\n        result.original.unshift({\n          content: originalChars[i - 1],\n          type: 'removed'\n        });\n        i--;\n      } else {\n        result.changed.unshift({\n          content: changedChars[j - 1],\n          type: 'added'\n        });\n        j--;\n      }\n    }\n    return result;\n  }\n  escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n}","map":{"version":3,"names":["DiffEngine","performComparison","originalText","changedText","settings","diffMode","ignoreCase","ignoreWhitespace","ignorePunctuation","processedOriginal","preprocessText","processedChanged","performWordComparison","performCharComparison","performLineComparison","text","options","processed","toLowerCase","replace","trim","originalLines","split","changedLines","diff","computeLineDiff","stats","linesAdded","linesRemoved","linesModified","originalResult","changedResult","original","forEach","lineInfo","index","lineObj","content","escapeHtml","type","lineNumber","push","changed","originalWords","splitIntoWords","changedWords","wordDiff","computeImprovedWordDiff","wordsAdded","wordsRemoved","wordsModified","totalChanges","originalHtml","changedHtml","item","test","charDiff","computeImprovedCharDiff","charactersAdded","charactersRemoved","charactersModified","m","length","n","dp","Array","fill","map","i","j","Math","max","result","unshift","regex","match","myersWordDiff","detectWordModifications","v","trace","d","k","x","y","buildWordPath","computeWordDiff","depth","prevK","prevX","prevY","diffResult","removedWord","addedWord","areWordsSimilar","word1","word2","abs","minLen","min","commonChars","myersCharDiff","groupCharacterChanges","originalChars","from","changedChars","buildCharPath","computeCharDiff","groupedOriginal","groupConsecutiveChanges","groupedChanged","items","grouped","currentGroup","div","document","createElement","textContent","innerHTML"],"sources":["C:/Users/Joem/quickdiff-react/src/utils/DiffEngine.js"],"sourcesContent":["export class DiffEngine {\r\n  performComparison(originalText, changedText, settings) {\r\n    const { diffMode, ignoreCase, ignoreWhitespace, ignorePunctuation } = settings;\r\n    \r\n    // Preprocess texts based on ignore options\r\n    const processedOriginal = this.preprocessText(originalText, { ignoreCase, ignoreWhitespace, ignorePunctuation });\r\n    const processedChanged = this.preprocessText(changedText, { ignoreCase, ignoreWhitespace, ignorePunctuation });\r\n    \r\n    switch (diffMode) {\r\n      case 'word':\r\n        return this.performWordComparison(processedOriginal, processedChanged);\r\n      case 'char':\r\n        return this.performCharComparison(processedOriginal, processedChanged);\r\n      default:\r\n        return this.performLineComparison(processedOriginal, processedChanged);\r\n    }\r\n  }\r\n\r\n  preprocessText(text, options) {\r\n    let processed = text;\r\n    \r\n    if (options.ignoreCase) {\r\n      processed = processed.toLowerCase();\r\n    }\r\n    \r\n    if (options.ignoreWhitespace) {\r\n      processed = processed.replace(/\\s+/g, ' ').trim();\r\n    }\r\n    \r\n    if (options.ignorePunctuation) {\r\n      processed = processed.replace(/[^\\w\\s]/g, '');\r\n    }\r\n    \r\n    return processed;\r\n  }\r\n\r\n  performLineComparison(originalText, changedText) {\r\n    const originalLines = originalText.split(/\\r?\\n/);\r\n    const changedLines = changedText.split(/\\r?\\n/);\r\n    \r\n    const diff = this.computeLineDiff(originalLines, changedLines);\r\n    \r\n    const stats = {\r\n      linesAdded: 0,\r\n      linesRemoved: 0,\r\n      linesModified: 0\r\n    };\r\n    \r\n    const originalResult = [];\r\n    const changedResult = [];\r\n    \r\n    // Process original lines\r\n    diff.original.forEach((lineInfo, index) => {\r\n      const lineObj = {\r\n        content: this.escapeHtml(lineInfo.content),\r\n        type: lineInfo.type,\r\n        lineNumber: index + 1\r\n      };\r\n      \r\n      if (lineInfo.type === 'removed') stats.linesRemoved++;\r\n      if (lineInfo.type === 'modified') stats.linesModified++;\r\n      \r\n      originalResult.push(lineObj);\r\n    });\r\n    \r\n    // Process changed lines\r\n    diff.changed.forEach((lineInfo, index) => {\r\n      const lineObj = {\r\n        content: this.escapeHtml(lineInfo.content),\r\n        type: lineInfo.type,\r\n        lineNumber: index + 1\r\n      };\r\n      \r\n      if (lineInfo.type === 'added') stats.linesAdded++;\r\n      \r\n      changedResult.push(lineObj);\r\n    });\r\n    \r\n    return {\r\n      originalLines: originalResult,\r\n      changedLines: changedResult,\r\n      stats\r\n    };\r\n  }\r\n\r\n  performWordComparison(originalText, changedText) {\r\n    const originalWords = this.splitIntoWords(originalText);\r\n    const changedWords = this.splitIntoWords(changedText);\r\n    \r\n    const wordDiff = this.computeImprovedWordDiff(originalWords, changedWords);\r\n    \r\n    const stats = {\r\n      wordsAdded: 0,\r\n      wordsRemoved: 0,\r\n      wordsModified: 0,\r\n      totalChanges: 0\r\n    };\r\n    \r\n    let originalHtml = '';\r\n    let changedHtml = '';\r\n    \r\n    // Process original words with better counting\r\n    wordDiff.original.forEach(item => {\r\n      if (item.type === 'removed') {\r\n        // Only count actual words, not whitespace\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          stats.wordsRemoved++;\r\n        }\r\n        originalHtml += `<span class=\"word-removed\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          stats.wordsModified++;\r\n        }\r\n        originalHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        originalHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Process changed words with better counting\r\n    wordDiff.changed.forEach(item => {\r\n      if (item.type === 'added') {\r\n        // Only count actual words, not whitespace\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          stats.wordsAdded++;\r\n        }\r\n        changedHtml += `<span class=\"word-added\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        if (item.content.trim() && /\\S/.test(item.content)) {\r\n          // Don't double count modified words\r\n        }\r\n        changedHtml += `<span class=\"word-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        changedHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Calculate total changes more accurately\r\n    stats.totalChanges = stats.wordsAdded + stats.wordsRemoved + stats.wordsModified;\r\n    \r\n    return {\r\n      originalLines: [{ content: originalHtml, type: '', lineNumber: 1 }],\r\n      changedLines: [{ content: changedHtml, type: '', lineNumber: 1 }],\r\n      stats\r\n    };\r\n  }\r\n\r\n  performCharComparison(originalText, changedText) {\r\n    const charDiff = this.computeImprovedCharDiff(originalText, changedText);\r\n    \r\n    const stats = {\r\n      charactersAdded: 0,\r\n      charactersRemoved: 0,\r\n      charactersModified: 0,\r\n      totalChanges: 0\r\n    };\r\n    \r\n    let originalHtml = '';\r\n    let changedHtml = '';\r\n    \r\n    // Process original characters with grouping for better visualization\r\n    charDiff.original.forEach(item => {\r\n      if (item.type === 'removed') {\r\n        stats.charactersRemoved++;\r\n        originalHtml += `<span class=\"char-removed\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        stats.charactersModified++;\r\n        originalHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        originalHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Process changed characters with grouping\r\n    charDiff.changed.forEach(item => {\r\n      if (item.type === 'added') {\r\n        stats.charactersAdded++;\r\n        changedHtml += `<span class=\"char-added\">${this.escapeHtml(item.content)}</span>`;\r\n      } else if (item.type === 'modified') {\r\n        // Don't double count modified characters\r\n        changedHtml += `<span class=\"char-modified\">${this.escapeHtml(item.content)}</span>`;\r\n      } else {\r\n        changedHtml += this.escapeHtml(item.content);\r\n      }\r\n    });\r\n    \r\n    // Calculate total changes\r\n    stats.totalChanges = stats.charactersAdded + stats.charactersRemoved + stats.charactersModified;\r\n    \r\n    return {\r\n      originalLines: [{ content: originalHtml, type: '', lineNumber: 1 }],\r\n      changedLines: [{ content: changedHtml, type: '', lineNumber: 1 }],\r\n      stats\r\n    };\r\n  }\r\n\r\n  computeLineDiff(originalLines, changedLines) {\r\n    const m = originalLines.length;\r\n    const n = changedLines.length;\r\n    \r\n    // Create DP table for LCS\r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    // Fill the DP table\r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (originalLines[i - 1] === changedLines[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Backtrack to build the diff\r\n    const result = { original: [], changed: [] };\r\n    let i = m, j = n;\r\n    \r\n    while (i > 0 || j > 0) {\r\n      if (i > 0 && j > 0 && originalLines[i - 1] === changedLines[j - 1]) {\r\n        result.original.unshift({\r\n          content: originalLines[i - 1],\r\n          type: 'unchanged'\r\n        });\r\n        result.changed.unshift({\r\n          content: changedLines[j - 1],\r\n          type: 'unchanged'\r\n        });\r\n        i--; j--;\r\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\r\n        result.original.unshift({\r\n          content: originalLines[i - 1],\r\n          type: 'removed'\r\n        });\r\n        i--;\r\n      } else {\r\n        result.changed.unshift({\r\n          content: changedLines[j - 1],\r\n          type: 'added'\r\n        });\r\n        j--;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  splitIntoWords(text) {\r\n    const regex = /(\\S+|\\s+)/g;\r\n    return text.match(regex) || [];\r\n  }\r\n\r\n  computeImprovedWordDiff(originalWords, changedWords) {\r\n    // Use Myers' algorithm for better diff performance\r\n    const result = this.myersWordDiff(originalWords, changedWords);\r\n    \r\n    // Post-process to detect word modifications (similar words that changed)\r\n    return this.detectWordModifications(result);\r\n  }\r\n\r\n  myersWordDiff(originalWords, changedWords) {\r\n    const m = originalWords.length;\r\n    const n = changedWords.length;\r\n    const max = m + n;\r\n    \r\n    const v = Array(2 * max + 1).fill(0);\r\n    const trace = [];\r\n    \r\n    for (let d = 0; d <= max; d++) {\r\n      trace.push([...v]);\r\n      \r\n      for (let k = -d; k <= d; k += 2) {\r\n        let x;\r\n        if (k === -d || (k !== d && v[k - 1 + max] < v[k + 1 + max])) {\r\n          x = v[k + 1 + max];\r\n        } else {\r\n          x = v[k - 1 + max] + 1;\r\n        }\r\n        \r\n        let y = x - k;\r\n        \r\n        while (x < m && y < n && originalWords[x] === changedWords[y]) {\r\n          x++;\r\n          y++;\r\n        }\r\n        \r\n        v[k + max] = x;\r\n        \r\n        if (x >= m && y >= n) {\r\n          return this.buildWordPath(originalWords, changedWords, trace, d);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Fallback to simple LCS if Myers fails\r\n    return this.computeWordDiff(originalWords, changedWords);\r\n  }\r\n\r\n  buildWordPath(originalWords, changedWords, trace, d) {\r\n    const result = { original: [], changed: [] };\r\n    let x = originalWords.length;\r\n    let y = changedWords.length;\r\n    \r\n    for (let depth = d; depth > 0; depth--) {\r\n      const v = trace[depth];\r\n      const k = x - y;\r\n      const max = originalWords.length + changedWords.length;\r\n      \r\n      let prevK;\r\n      if (k === -depth || (k !== depth && v[k - 1 + max] < v[k + 1 + max])) {\r\n        prevK = k + 1;\r\n      } else {\r\n        prevK = k - 1;\r\n      }\r\n      \r\n      const prevX = v[prevK + max];\r\n      const prevY = prevX - prevK;\r\n      \r\n      while (x > prevX && y > prevY) {\r\n        result.original.unshift({ content: originalWords[x - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedWords[y - 1], type: 'unchanged' });\r\n        x--;\r\n        y--;\r\n      }\r\n      \r\n      if (depth > 0) {\r\n        if (x > prevX) {\r\n          result.original.unshift({ content: originalWords[x - 1], type: 'removed' });\r\n          x--;\r\n        } else {\r\n          result.changed.unshift({ content: changedWords[y - 1], type: 'added' });\r\n          y--;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  detectWordModifications(diffResult) {\r\n    // Look for patterns where a word was removed and another added nearby\r\n    const original = [...diffResult.original];\r\n    const changed = [...diffResult.changed];\r\n    \r\n    // Simple heuristic: if words are similar (edit distance < 3), mark as modified\r\n    for (let i = 0; i < original.length; i++) {\r\n      if (original[i].type === 'removed') {\r\n        const removedWord = original[i].content.trim();\r\n        \r\n        // Look for similar added words\r\n        for (let j = 0; j < changed.length; j++) {\r\n          if (changed[j].type === 'added') {\r\n            const addedWord = changed[j].content.trim();\r\n            \r\n            if (removedWord && addedWord && this.areWordsSimilar(removedWord, addedWord)) {\r\n              original[i].type = 'modified';\r\n              changed[j].type = 'modified';\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return { original, changed };\r\n  }\r\n\r\n  areWordsSimilar(word1, word2) {\r\n    // Simple similarity check - could be enhanced with Levenshtein distance\r\n    if (word1.length === 0 || word2.length === 0) return false;\r\n    if (Math.abs(word1.length - word2.length) > 3) return false;\r\n    \r\n    // Check if they share common prefix/suffix\r\n    const minLen = Math.min(word1.length, word2.length);\r\n    let commonChars = 0;\r\n    \r\n    for (let i = 0; i < minLen; i++) {\r\n      if (word1[i].toLowerCase() === word2[i].toLowerCase()) {\r\n        commonChars++;\r\n      }\r\n    }\r\n    \r\n    return commonChars / minLen > 0.6; // 60% similarity threshold\r\n  }\r\n\r\n  computeWordDiff(originalWords, changedWords) {\r\n    const m = originalWords.length;\r\n    const n = changedWords.length;\r\n    \r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (originalWords[i - 1] === changedWords[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const result = { original: [], changed: [] };\r\n    let i = m, j = n;\r\n    \r\n    while (i > 0 || j > 0) {\r\n      if (i > 0 && j > 0 && originalWords[i - 1] === changedWords[j - 1]) {\r\n        result.original.unshift({ content: originalWords[i - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedWords[j - 1], type: 'unchanged' });\r\n        i--; j--;\r\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\r\n        result.original.unshift({ content: originalWords[i - 1], type: 'removed' });\r\n        i--;\r\n      } else {\r\n        result.changed.unshift({ content: changedWords[j - 1], type: 'added' });\r\n        j--;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  computeImprovedCharDiff(originalText, changedText) {\r\n    // Use character-level Myers algorithm with grouping for better visualization\r\n    const result = this.myersCharDiff(originalText, changedText);\r\n    \r\n    // Group consecutive changes for better readability\r\n    return this.groupCharacterChanges(result);\r\n  }\r\n\r\n  myersCharDiff(originalText, changedText) {\r\n    const originalChars = Array.from(originalText);\r\n    const changedChars = Array.from(changedText);\r\n    \r\n    const m = originalChars.length;\r\n    const n = changedChars.length;\r\n    const max = m + n;\r\n    \r\n    if (max === 0) {\r\n      return { original: [], changed: [] };\r\n    }\r\n    \r\n    const v = Array(2 * max + 1).fill(0);\r\n    const trace = [];\r\n    \r\n    for (let d = 0; d <= max; d++) {\r\n      trace.push([...v]);\r\n      \r\n      for (let k = -d; k <= d; k += 2) {\r\n        let x;\r\n        if (k === -d || (k !== d && v[k - 1 + max] < v[k + 1 + max])) {\r\n          x = v[k + 1 + max];\r\n        } else {\r\n          x = v[k - 1 + max] + 1;\r\n        }\r\n        \r\n        let y = x - k;\r\n        \r\n        while (x < m && y < n && originalChars[x] === changedChars[y]) {\r\n          x++;\r\n          y++;\r\n        }\r\n        \r\n        v[k + max] = x;\r\n        \r\n        if (x >= m && y >= n) {\r\n          return this.buildCharPath(originalChars, changedChars, trace, d);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Fallback to simple character diff\r\n    return this.computeCharDiff(originalText, changedText);\r\n  }\r\n\r\n  buildCharPath(originalChars, changedChars, trace, d) {\r\n    const result = { original: [], changed: [] };\r\n    let x = originalChars.length;\r\n    let y = changedChars.length;\r\n    \r\n    for (let depth = d; depth > 0; depth--) {\r\n      const v = trace[depth];\r\n      const k = x - y;\r\n      const max = originalChars.length + changedChars.length;\r\n      \r\n      let prevK;\r\n      if (k === -depth || (k !== depth && v[k - 1 + max] < v[k + 1 + max])) {\r\n        prevK = k + 1;\r\n      } else {\r\n        prevK = k - 1;\r\n      }\r\n      \r\n      const prevX = v[prevK + max];\r\n      const prevY = prevX - prevK;\r\n      \r\n      while (x > prevX && y > prevY) {\r\n        result.original.unshift({ content: originalChars[x - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedChars[y - 1], type: 'unchanged' });\r\n        x--;\r\n        y--;\r\n      }\r\n      \r\n      if (depth > 0) {\r\n        if (x > prevX) {\r\n          result.original.unshift({ content: originalChars[x - 1], type: 'removed' });\r\n          x--;\r\n        } else {\r\n          result.changed.unshift({ content: changedChars[y - 1], type: 'added' });\r\n          y--;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  groupCharacterChanges(diffResult) {\r\n    // Group consecutive character changes for better visualization\r\n    const groupedOriginal = this.groupConsecutiveChanges(diffResult.original);\r\n    const groupedChanged = this.groupConsecutiveChanges(diffResult.changed);\r\n    \r\n    return { original: groupedOriginal, changed: groupedChanged };\r\n  }\r\n\r\n  groupConsecutiveChanges(items) {\r\n    if (!items || items.length === 0) return [];\r\n    \r\n    const grouped = [];\r\n    let currentGroup = null;\r\n    \r\n    for (const item of items) {\r\n      if (currentGroup && currentGroup.type === item.type && item.type !== 'unchanged') {\r\n        // Continue the current group\r\n        currentGroup.content += item.content;\r\n      } else {\r\n        // Start a new group\r\n        if (currentGroup) {\r\n          grouped.push(currentGroup);\r\n        }\r\n        currentGroup = { ...item };\r\n      }\r\n    }\r\n    \r\n    if (currentGroup) {\r\n      grouped.push(currentGroup);\r\n    }\r\n    \r\n    return grouped;\r\n  }\r\n\r\n  computeCharDiff(originalText, changedText) {\r\n    const originalChars = Array.from(originalText);\r\n    const changedChars = Array.from(changedText);\r\n    \r\n    const m = originalChars.length;\r\n    const n = changedChars.length;\r\n    \r\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\r\n    \r\n    for (let i = 1; i <= m; i++) {\r\n      for (let j = 1; j <= n; j++) {\r\n        if (originalChars[i - 1] === changedChars[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1] + 1;\r\n        } else {\r\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const result = { original: [], changed: [] };\r\n    let i = m, j = n;\r\n    \r\n    while (i > 0 || j > 0) {\r\n      if (i > 0 && j > 0 && originalChars[i - 1] === changedChars[j - 1]) {\r\n        result.original.unshift({ content: originalChars[i - 1], type: 'unchanged' });\r\n        result.changed.unshift({ content: changedChars[j - 1], type: 'unchanged' });\r\n        i--; j--;\r\n      } else if (i > 0 && (j === 0 || dp[i - 1][j] >= dp[i][j - 1])) {\r\n        result.original.unshift({ content: originalChars[i - 1], type: 'removed' });\r\n        i--;\r\n      } else {\r\n        result.changed.unshift({ content: changedChars[j - 1], type: 'added' });\r\n        j--;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  escapeHtml(text) {\r\n    const div = document.createElement('div');\r\n    div.textContent = text;\r\n    return div.innerHTML;\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}